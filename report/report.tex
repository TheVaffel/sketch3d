\documentclass[english]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{hyperref}


\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\setlength{\headheight}{40pt}

\begin{document}

\title{ParaGem - An Intuitive Tool for Creating Procedural Content}

\author{HÃ¥kon Flatval}

\maketitle
\thispagestyle{fancy}

\begin{center}

  % Life hack, create abstract before anyone tells you it's impossible to achieve what you are doing
  {\bf Abstract:} Procedural generation with shape grammars is powerful, but is unintuitive and time consuming to specify, even for experts. In this project, I have looked closer at generating geometric shape grammars more intuitively, by allowing the user to get real-time feedback on their changes to the grammar. The created application allows the user to draw and specify the shape by using primitives. The primitives can be linked together with \textit{pivot points}, for which the user will specify rules, which they will adhere to when the model is used for generating a large amount of objects procedurally. Letting the user specify complicated structure and connections turns out to be favorable in many situations, despite requiring a bit of technical knowledge by the artist.
  
\end{center}

\section{Introduction}

Procedural generation is a powerful tool for artists, enabling them to create a large amount of geometric entities that can incorporate both natural-looking variety and order alike. One of the most prominent problems with procedural generation today, is that a significant amount of time and knowledge is required in order to successfully create a procedurally generated population of any kind of entity.

In this document, I will discuss my project ParaGem, a modeling tool for artists that allows for specifying scalar parameters and high-level connections in-between primitives of the geometry. The intended purpose of the program is to enable creation of models whose geometry depends on a set of parameters, so that many variations of the same model can be produced by varying these parameters. The program is largely inspired by Structured Annotations introduced by  Gingold et al. \cite{gingold09}, both considering the choice of geometric primitives for modeling and representation of relations between model components.

While ParaGem would be too simplistic for industrial use compared to commercial procedural content tools, like SideFX' Houdini \cite{houdini} and Esri's CityEngine \cite{cityengine}, it is rather aimed to be a useful tool for gaining an intuition of the behavior of procedural content, and as a way for artists to communicate their intentions of procedural content e.g. how size, asymmetry and complexity can vary and are related between components of the model.

ParaGem is not finished, and I am therefore not able to report any user experience of the program, nor its practical utility. However, I will present an overview of ParaGem (section \ref{section_architecture}), its different components (section \ref{section_components}), and the technical details of the underlying algorithms (section \ref{section_algorithms}). At last, I will highlight what further work must be conducted to finish the application, and ideas for future directions of the project (section \ref{section_future_work}).

I will start off with a survey of related work.

\section{Related Work}

Although my work is within the field of procedural content generation, it has many aspects related to 3D-modeling, and in particular, sketch-based 3D-modeling.

\subsection{Procedural Content}

Procedural content generation (PCG) is by no means a new subject. PCG has been used in modeling diverse entities like plants \cite{plant_l_system}, buildings \cite{building_shape_grammar}, cities \cite{procedural_city_modeling}, and terrains \cite{early_terrain_generation} for a long time. 


Many surveys exist, focusing on generation of different types of content. The recent survey by Galin et al. \cite{terrain_survey_2019} provides an extensive survey of terrain generation. Hendrikx et al. \cite{pcg_survey_2013} and Carli et al. \cite{brazilian_pcg_survey} both consider procedural content as used in games. Freiknecht et al. \cite{pcg_survey_2017} also consider games in their survey, but also includes PCG in domains outside computer graphics, like NPC interaction and quests. The adaption into industry is also well-documented (e.g. \cite{amato2017}).

One popular way of realizing PCG is through the use of shape grammars \cite{stiny2006shape}. Shape grammars are probabilistic formal grammars where terminal symbols can correspond geometric meshes -- primitive shapes. Like normal grammars, shape grammars work by repeatedly replacing symbols with other symbols using production rules until only terminal symbols remain, and then produce geometry from the resulting string. Shape grammars have been successfully used for modeling buildings \cite{building_shape_grammar} and plants (with L-systems, that are closely related to shape grammars) \cite{plant_l_system}.


%The power of procedural generation has been proven in the creation of plants (SOME CITATION), buildings (SOME OTHER CITATION) and even whole cities (THAT PARISH PAPER, YOU KNOW). There are various ways of seeding procedural generation, shape grammars being among the most popular ones.

\subsection{Sketch-Based Modeling}

3D-modeling is a task that requires significant effort and specialized experience to perform successfully and efficiently, making it a bottleneck when communicating three-dimensional models by e.g. artists. Sketch-based modeling is one attempt at overcoming this challenge. 



The goal of this project has been to unite the power of procedural content generation with the simplicity of sketch-based modeling. The goal is to create a new, simple way of communicating geometric entities that also encapsulates information about natural variation.

\section{Overview} \label{section_architecture}

\section{Components} \label{section_components}

\section{Algorithms} \label{section_algorithms}

\subsection{Laplacian Curve Editing}

The following describes how we compute a new spline curve after one of the points has moved. Similarily to the one used by Gingold et al. \cite{gingold09}, this algorithm is based on \textit{Laplacian Surface Editing} by Sorkine et al. \cite{sorkine04}. The derivation closely follows that of Sorkine et al., but with added detail to clarify how the method is used in practice.

Let the $V$ denote the initial positions of the control points before movement, consisting of the individual nodes positions $\mathbf{v}_i \in V$. Next, let $U \subset \mathbb{Z}$ be a set of indices refering to points we want to keep fixed, and let $\mathbf{u}_i$ be the fixed positions of $\mathbf{v}_i \in V$ for each $ i \in U$. Given the fixed positions $\mathbf{u}_i$ and the initial positions $V$, we want to compute the new positions $V'$, consisting of the individual positions $\mathbf{v}'_i \in V'$, that preserve the local structure of the curve, while also conforming to the new fixed positions.

In practice, $V$ will be a column vector of length $2n$, $n$ being the number of points. The $n$ first elements will be the $x$-coordinates of the points $\mathbf{v}_{i_x}$, $i \in [1..n]$, and the final $n$ elements will be the $y$-coordinates. $V'$ will have a similar structure.

The basic procedure for editing the curve will consist of the user choosing a set of points (the region of interest, RoI), that can be manipulated, and then dragging one of these (the ``handle'') to a new position. In this case, the set of indices for fixed points $U$ will contain the index of all points not in the RoI, in addition to the point dragged by the user. As a result, the algorithm will compute a new curve by mostly moving the points in the RoI to be consistent with the points outside the RoI and the new position of the handle.

Let $\mathcal{\mathbf{v_i}}$ denote the Laplacian of vector $\mathbf{v_i}$. If we let $\mathcal{N}_i$ denote the set of neighbors to vertex $i$, whichin case of a curve  will be $i+1$ and $i - 1$, provided they exist. The Laplacian of a vertex can now be written as $\mathcal{L}(\mathbf{v_i}) = \mathbf{v_i} - \sum_{j \in \mathcal{N}_i}\mathbf{v_j} / |\mathcal{N}_i|$. We see that this transform is linear in the positions of the curve, so that we can let $L$ be the \textit{Laplacian matrix} such that $L\cdot V$ produces the vector $\Delta$ containing the Laplacian coordinates of the vertices. Denote the Laplacian transformation of $\mathbf{v}_i$ as $\mathbf{\delta}_i$.

We will formulate the problem as a sparse linear system, which may subsequently be solved with an off-the-shelf solver. Consider the following energy function:

\[
E_0(V') = \sum_{i = 1}^n || \mathbf{\delta}_i - \mathcal{L}(\mathbf{v'}_i) ||^2 + \sum_{i \in U} || \mathbf{v}_i - \mathbf{v'}_i||^2
\]

When minimizing this function, the first term will ensure that the laplacian of the new and old points stay mostly the same, and the second term will ensure that our fixed points stay close to their original positions.

One aspect that this formulation does not account for, is that movement of a point will disallow rotation and scaling of the Laplacian coordinates, although in general, we want to allow for those transformations to occur. 

Thus, we formulate a new energy function that can account for transformations:

\begin{equation}
  E(V') = \sum_{i = 1}^n || T_i(V') \mathbf{\delta}_i - \mathbf{\delta'}_i||^2 + \sum_{i \in U} || \mathbf{v}_i - \mathbf{v'}_i||^2.
  \label{eq1}
\end{equation}

We want to choose a transformation that minimizes the first term, in other words minimizes

\[
G_i(T_i) = || T_i\mathbf{v}_i - \mathbf{v'}_i ||^2 + \sum_{j \in \mathcal{N}_i}||T_i \mathbf{v}_j - \mathbf{v'}_j||^2
\]

We will discuss how to optimize for $V'$ and $T_i$ simultaneously, but first, we must note that if we leave $T_i$ unconstrained, the minimizer of $G_i$ will be a membrane solution, a solution where all vertices between two fixed vertices will form a straight line, which will defeat our purpose of creating a new ``naturally'' curved spline.

The solution to this, as proposed by Sorkine et al., is to only allow for isotropic scaling and small rotations. They argue that anisotropic scaling may flatten a point in its normal direction, diminishing its Laplacian coordinate. Specifically, the transformation will take the following form (in two dimensions):

\[
T_i = \left[
  \begin{matrix}
    s_i & -h_i \\
    h_i & s_i
  \end{matrix}
  \right]
\]

As we see, only small rotations (with $h_i = \sin \theta$, $\theta$ being the angle of rotation) will be describable with reasonable accuracy by this matrix, although Sorkine et al. propose ways of working around this restriction.

An important question remains - how can we formulate an optimization problem where both $V'$ and the $T_i$'s are unknown? The solution provided by Sorkine et al. is to formulate $T_i$ as a linear function of $V'$, and encorporate the coefficients of that linear function into the original linear system. Practically, this is done in the following way:

First, we formulate an optimization problem to find the coefficients $[s_i, h_i]^T$ from $G_i$. We see that if we let

\[
A_i = \begin{bmatrix}
  v_{k_x} & -v_{k_y} \\
  \vdots &  \vdots \\
  v_{k_y} &  v_{k_x} \\
  \vdots &  \vdots
\end{bmatrix}
\text{ for } k \in \{i\} + \mathcal{N}_i
\],

the energy function $G_i$ can simply be written as

\[
||A_i[s_i, h_i]^T - \mathbf{b}_i||^2
\]

where $\mathbf{b}_i$ is defined by

\[
\mathbf{b}_i = \begin{bmatrix}
  v'_{k_x} \\
  \vdots \\
  v'_{k_y} \\
  \vdots
\end{bmatrix}
\text{ for } k \in \{i\} + \mathcal{N}_i
\],

This is a least-squares problem with the closed-form solution

\[
\begin{bmatrix}
  s_i \\
  h_i \\
\end{bmatrix}
= (A_i^TA_i)^{-1}A_i^T\mathbf{b}_i
\].

We thus see that the coefficients of $T_i$ are linear in $V'$. Let $M_i = (A_i^TA_i)^{-1}A_i^T\mathbf{b}_i$. We now turn our attention back to the energy function $E(V')$. We will minimize it by formulating it as quadratic optimization problem $||BV' - \mathbf{c}||^2$, where $B$ has dimensions $(2n + 2|U|) \times 2n$ and $\mathbf{c}$ has dimensions $(2n + 2|U|) \times 1$.

We first discuss the structure of $\mathbf{c}$. The first $2n$ elements will all be zero, as we simply wish to minimize the dot products of $V'$ with the first $2n$ rows of $B$, which we will discuss in a bit. The final $2|U|$ rows of $\mathbf{c}$ contain first the $x$-coordinates of all the fixed points, and then the $y$-coordinates, or algebraically:

\[
\mathbf{c} = 
\begin{bmatrix}
  0 \\
  \vdots \\
  0 \\
  v_{u_x} \\
  \vdots \\
  v_{u_y} \\
  \vdots
\end{bmatrix}
\text{ for } u \in U
\]

Next, we define the rows of $B$. The $2n$ first rows will describe the terms $T_i(V')\mathbf{\delta}_i - \mathbf{\delta'}_i$ of equation \ref{eq1}, separated into $x$- and $y$-components as usual. The $x$-part of the term translates into $s_i\mathbf{\delta}_{i_x} + h_i\mathbf{\delta}_{i_y} - \mathbf{\delta'}_{i_x}$. But, as we have seen, $s_i$ and $h_i$ can be written as linear functions of $V'$ using the aforementioned matrix $M_i$. Let $M'_{i_1}$ be a row vector of $2n$ elements containing the components of row 1 of $M_i$, such that each component has the same position in $M'_{i_1}$ as the corresponding component in $\mathbf{b}_i$ has in $V'$. In other words, so that $M'_{i_1}V' = s_i$. Similarily, let $M'_{i_2}$ be the vector so that $M'_{i_2}V' = h_i$.

Having these definitions handy, we now see that $s_i\mathbf{\delta}_{i_x} + h_i\mathbf{\delta}_{i_y} - \mathbf{\delta'}_{i_x} = (\mathbf{\delta}_{i_x}M'_{i_1} + \mathbf{\delta}_{i_y}M'_{i_2} - L_i)V'$, where $L_i$ is the $i$'th row of the Laplacian, so that the left-hand factor of the last expression will be the $i$'th row of $B$ for $i \leq n$. For $i > n$, we have a corresponding expression, but for the $y$-component of the term $T_i(V') \mathbf{\delta}_i - \mathbf{\delta'}_i$.

The final $2|U|$ rows of $B$ will have a single 1 each, on the position corresponding to component of $\mathbf{v'}_u$ for $u \in U$ in the same row of $\mathbf{c}$. In notation, row $i$ of $B$ will look like this:

\[
B_i = \left\{\begin{array}{lr}
\mathbf{\delta}_{i_x}M'_{i_1} - \mathbf{\delta}_{i_y}M'_{i_2} - L_i & \text{for } i \leq n \\
\mathbf{\delta}_{{(i-n)}_x}M'_{{(i-n)}_2} + \mathbf{\delta}_{{(i-n)}_y}M'_{{(i-n)}_1} - L_{i-n} & \text{for } n < i \leq 2n \\
\mathbf{e}^T_{u_{(i - 2n)}} & \text{for } 2n < i \leq 2n + |U| \\
\mathbf{e}^T_{n + u_{(i - 2n - |U|)}} & \text{for } 2n + |U| < i \leq 2n + 2|U|
\end{array}\right\}
\]

where $\mathbf{e_i}$ is the column vector with zeros everywhere except on position $i$, and $u_i$ is the $i$'th integer in $U$, in the same order as in the definition of $\mathbf{c}$.

Finally, we but the pieces together and conclude that the minimization objective

\[
||BV'- \mathbf{c}||^2
\]

is a sparse system with unknown vector $V'$. The system is overdetermined, so we find the least squares solution by solving the sparse linear system

\[
B^TBV' = B^T\mathbf{c}
\],
so that, in the end, we find the new curve vertices $V'$.

\subsection{Modifications}

Although the Laplacian Curve Editing approach provides a satisfying approach to edit a curve, the fixed points were found to move an unacceptable amount due to having a least-squares constraint and not being completely fixed. We probably encounter this problem because, unlike Sorkine et al., we have a limited number of vertices in the spline (usually less than 100), which make them more apt to move larger distances than if we had, say, tens of thousands of vertices, like in the meshes used by Sorkine et al.

This is fixed with a larger weight on the fixed-point terms of the optimization objective, practically conducted by multiplying both the non-zero elements of the $2|U|$ bottom rows of $B$ and the last $2|U|$ elements of $\mathbf{c}$ by the same constant factor.

\section{Future Work} \label{section_future_work}

% I go through both what is needed to finish this project, and 

\subsection{Work Remaining for Project Finish}

\subsection{Future Directions}

% Mention textures (noise-driven?), 

% Include \cite{schmidt08} - work that is a bit more related to what I have in mind (but perhaps not as ambitious, with recursion and stuff).
  
\section{Conclusions}

% Project not finished, but we have shown examples of it working (make sure to actually show examples of it working)

\bibliography{report}
\bibliographystyle{plain}

\end{document}
