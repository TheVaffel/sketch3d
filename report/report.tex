\documentclass[english]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{hyperref}


\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\setlength{\headheight}{40pt}

\begin{document}

\title{ParaGem - An Intuitive Tool for Creating Procedural Content}

\author{HÃ¥kon Flatval}

\maketitle
\thispagestyle{fancy}

\begin{center}

  % Life hack, create abstract before anyone tells you it's impossible to achieve what you are doing
  {\bf Abstract:} Procedural generation with shape grammars is powerful, but is unintuitive and time consuming to specify, even for experts. In this project, I have looked closer at generating geometric shape grammars more intuitively, by allowing the user to get real-time feedback on their changes to the grammar. The created application allows the user to draw and specify the shape by using primitives. The primitives can be linked together with \textit{pivot points}, for which the user will specify rules, which they will adhere to when the model is used for generating a large amount of objects procedurally. Letting the user specify complicated structure and connections turns out to be favorable in many situations, despite requiring a bit of technical knowledge by the artist.
  
\end{center}

\section{Introduction}

Procedural generation is a powerful tool for artists, enabling them to create a large amount of geometric entities that can incorporate both natural-looking variety and order alike. One of the most prominent problems with procedural generation today, is that a significant amount of time and knowledge is required in order to successfully create a procedurally generated population of any kind of entity.

In this document, I will discuss my project ParaGem, a modeling tool for artists that allows for specifying scalar parameters and high-level connections in-between primitives of the geometry. The intended purpose of the program is to enable creation of models whose geometry depends on a set of parameters, so that many variations of the same model can be produced by varying these parameters. The program is largely inspired by Structured Annotations introduced by  Gingold et al. \cite{gingold09}, both considering the choice of geometric primitives for modeling and representation of relations between model components.

While ParaGem would be too simplistic for industrial use compared to commercial procedural content tools, like SideFX' Houdini \cite{houdini} and Esri's CityEngine \cite{cityengine}, it is rather aimed to be a useful tool for gaining an intuition of the behavior of procedural content, and as a way for artists to communicate their intentions of procedural content e.g. how size, asymmetry and complexity can vary and are related between components of the model.

ParaGem is not finished, and I am therefore not able to report any user experience of the program, nor its practical utility. However, I will present an overview of ParaGem (section \ref{section_architecture}), its different implemented components (section \ref{section_components}), and the technical details of the underlying algorithms (section \ref{section_algorithms}). At last, I will briefly discuss the implementation details of my project (section \ref{section_implementation}) before I highlight what further work must be conducted to finish the application, and ideas for future directions of the project (section \ref{section_future_work}).

I will start off with a survey of related work.

\pagebreak

\section{Related Work}

Although my work is within the field of procedural content generation, it has many aspects related to interactive 3D-modeling, and in particular, sketch-based 3D-modeling. I will discuss previous work within both of these fields.

\subsection{Procedural Content}

Procedural content generation (PCG) is by no means a new subject. PCG has been used in modeling diverse entities like plants \cite{plant_l_system}, buildings \cite{building_shape_grammar}, cities \cite{procedural_city_modeling}, and terrains \cite{early_terrain_generation} for a long time. 

Many surveys exist, focusing on generation of different types of content. The recent survey by Galin et al. \cite{terrain_survey_2019} provides an extensive survey of terrain generation. Hendrikx et al. \cite{pcg_survey_2013} and Carli et al. \cite{brazilian_pcg_survey} both consider procedural content as used in games. Freiknecht et al. \cite{pcg_survey_2017} also consider games in their survey, but also includes PCG in domains outside computer graphics, like NPC interaction and quests. The adaption into industry is also well-documented (e.g. \cite{amato2017}).

One popular way of realizing PCG is through the use of shape grammars \cite{stiny2006shape}. Shape grammars are probabilistic formal grammars where terminal symbols can correspond geometric meshes -- primitive shapes. Like normal grammars, shape grammars work by repeatedly replacing symbols with other symbols using production rules until only terminal symbols remain, and then produce geometry from the resulting string. Shape grammars have been successfully used for modeling buildings \cite{building_shape_grammar} and plants \cite{plant_l_system} (with L-systems, that are closely related to shape grammars).

\subsection{Sketch-Based Modeling} \label{subsection_review_sketch}

3D-modeling is a task that requires significant effort and specialized experience to perform successfully and efficiently, making it a bottleneck when communicating three-dimensional models by e.g. artists. Sketch-based modeling is one attempt at overcoming this challenge. 

\cite{gingold09} is an example of such an approach, where the user creates 3D models out of pre-defined primitive. Their most important primitive is the generalized cylinder, a shape of circular cross-section that is extruded along a spline in three dimensions. The user inputs strokes to define the spline, from which the application creates the generalized cylinder.

% MENTION THE KINDA IMPORTANT ANNOTATION SYSTEM

At extension of Gingold et al.'s approach was presented by Kazmi et al. \cite{hybrid_character_modeling}, where heightmaps are created from textures, which can be turned into fine-grained detail 

Other approaches to sketch-based modeling include that of Huang et al. \cite{procedural_sketch_cnn}, in which the authors use two convolutional neural networks (CNN) to create a threedimensional model from a hand-drawn sketch, provided it belongs to one of a few pre-determined object classes. One of the CNNs deduces which of the classes the sketch represents, while the other determines various parameters of the object so that the final model resembles the sketch as much as possible.

A few other related methods, although they use RGB photographs instead of sketches, are Pixel2Mesh \cite{pixel2mesh} by Wang et al. and procedural modeling of a building from an image \cite{procedural_building_from_image} by Nishida et al. Pixel2Mesh takes as input a photograph of a 3D object and returns a 3D mesh of the same object. It uses a graph-based convolutional neural network to deform a sphere (whose mesh is represented by a graph) into the desired object.

Nishida et al.'s approach also takes an RGB image as input, as well as a user-specified outline of the building in the image. Subsequently, the CNN classifies the building based on building mass style, and then other CNNs to determine style of ledges, roof and windows together with various parameters for all of these components. The result is a shape grammar that can be used for generating similar buildings.

\subsection{Combining Procedural Generation and Sketch-based Modeling}

As may be apparent from section \ref{subsection_review_sketch}, work with sketch-based modeling often make use of procedural models to reduce the number of possible interpretations of an input sketch. Nshida et al. \cite{sketch_based_urban_modeling} explicitly creates procedural models; models whose exact geometry depends on a set of variables. While their work restricts itself to modeling buildings, the recent work of Wailly et al. \cite{sketching_parameterized_models} generalizes it to arbitrary models, allowing the user to draw a variety of geometric primitives.

At last, the work by Schmidt and Singh \cite{schmidt08} on modeling using surface trees should be mentioned in this context. They represent alterations of a surface as a tree of different edits, allowing for consistent behavior when changing and copying large ``base'' edits. Although not an explicit goal of their method, the resulting geometry is a procedural model, which could potentially be used for procedural content generation.

\pagebreak

\section{Overview} \label{section_architecture}

The goal of ParaGem has been to unite the power of procedural content generation with the simplicity of sketch-based modeling. The intention is to create a new, simple way of communicating geometric entities that also encapsulates information about natural variation. My approach is heavily inspired by that of Gingold et al. \cite{gingold09}, and my aim has been to extend their approach by allowing the user to create procedural models.

In this section, I will describe how ParaGem is intended to work and how it is used. I will not distinguish between what has been implemented and not, this will be expanded upon in section \ref{section_components}.

\subsection{Features}

A model in ParaGem consists of several \textit{submodels}, a set of variables, and a set of annotations, each of these concepts will be explained in the following.

\subsubsection{Submodels}

The user is allowed to make multiple submodels that constitute one model. Submodels work in much the same way as classes do in object-oriented programming. The user defines each submodel once, but can create multiple instances of each, potentially with different parameters. In this sense, the pre-defined geometric primitives of ParaGem are also submodels.
The model as a whole is represented by a tree structure whose nodes are instances of submodels. Each submodel is defined with a number of parameters, which will be propagated from parent nodes in the tree (or at the base node, defined by the user). The child nodes of each submodel instance is defined on submodule-(class-)level, but may depend on instance parameters. Submodels can be arranged in rows and grids on other submodels, and even allows for recursion.

\subsubsection{Variables}

Variables are scalar values that works as input parameters to submodels. They can also be defined as constants global to the whole model tree. There are a number of pre-defined functions that can work on one or multiple variables, like offsets, scaling, exponentials etc.

What makes variables a useful concept for procedural generation, is that they can be defined as ranges of possible values instead of single scalars. This is the way variation is introduced to the model.

Variables manifest themselves when used as input to annotations. 


\subsubsection{Annotations}

Annotations are descriptors  which can describe attributes like the size, position, curvature and shape of a part of a primitive. Annotations are what ties varibles to geometric attributes. Each annotation describes one attribute of one part of the model.

More interestingly, annotations can describe the relations between different components or parts of components of the full model, by having multiple annotations make use of the same variable. In this respect, the annotations are very similar to those presented by Gingold et al. in \cite{gingold09}. For example, this could let us create human models enforcing symmetry in limb sizes, or insects whose wings are required to be longer than their body length.

Another important aspect of the annotation system is the possibility to define recursive models. This enables the user to create complex models with repeated structures, such as trees. For this kind of annotation, the supplied variables determine attributes like scale, position, and recursion limit, as well as any custom scalar varables the user may want to propagate into the child model.

% EXAMPLES PLZZZ

\subsection{Workflow}

Like several of the aspects mentioned above, the workflow described in the following is not supported by the current implementation. This subsection serves as a vision for how the user will use the program.

At first, the user must make a new submodel.
In order to create a submodel, the user first chooses a primitive, and then makes a stroke on the screen to place and create the initial shape of the primitive in the scene. Then, the primitive can be edited by the user. The editing options and controls differ between each geometric primitive. In the case of the generalized cylinder, there are two primary methods for editing the shape; Laplacian curve editing and peeling, both of which will be explained in section \ref{section_components}.

The user can add multiple geometric primitives in the same submodel. Their poses in relation to each others will be fixed, unless otherwise specified by annotations.

% Create annotations

When creating a submodel, the user can at any time switch into annotation mode. Here, the user can choose between a range of annotation types; size, position, rotation and inclusion of other submodels. The user chooses an annotation type from a list, and then clicks the position at which the annotation is to be applied. Different types of annotations are applied to different features of the model -- size annotations are applied to a part of a geometric primitive, while inclusion of other submodels can be applied on the surface of the model. When an annotation is added, it will have default values for the attribute it influences. The user can change this value, or set it equal to some variable.

While in annotation mode, the user also has the opportunity to create variables. Each variable is either defined as an input parameter to the submodel, a static scalar value, or a range of values. One can also define a value as a function of one or more other values. For visualizing the model in the editor, input variables attain a default value, while value ranges attain the average of the range. Both can be changed to arbitrary values by the user.

Subsequently, the user can create several other submodels in a similar fashion, and is always allowed to go back and edit a previous one. The first submodel will initially be the ``base'' of the model; the root of the model tree. The user can change which submodel is the base model at will.

% Output to file

Finally, the user can visualize variations of the model through the gallery mode. The application creates a user-chosen number of models from the model tree created by the user, where each of the range variables are given a concrete value within its range, chosen uniformly at random. The user can scroll through the gallery and save interesting models in a common format (like \texttt{.obj}). The user can also save the model tree for future use and edits.

\pagebreak

\section{Implemented Components} \label{section_components}

\subsection{Drawing a Generalized Cylinder}

Like in Gingold et al., the most important primitive for modeling in ParaGem is the generalized cylinder. 

The user defines a generalized cylinder by drawing a curve on the screen, which is discretized into points, which again serve as control points for a spline. 
This spline is the ``central spine'' of the generalized cylinder. The cylinder is created by placing circles on interpolated points on the spline perpendicular to the direction of the spline, so that the spline is perceived to go through the circles. Then a mesh is ``wrapped'' around these circles to form the mesh surrounding the spline. The end pieces are simply hemispheres.



Naturally, ParaGem should support more geometric primitives, but only the generalized cylinder is implemented. It has had priority due to its flexibility and intuitive behavior, as proven in \cite{gingold09}.

\subsection{Shaping the cylinder}

\subsection{Creating Annotations}


\pagebreak

\section{Algorithms} \label{section_algorithms}

\subsection{Laplacian Curve Editing}

The following describes how we compute a new spline curve after one of the points has moved. Similarily to the one used by Gingold et al. \cite{gingold09}, this algorithm is based on \textit{Laplacian Surface Editing} by Sorkine et al. \cite{sorkine04}. The derivation closely follows that of Sorkine et al., but with added detail to clarify how the method is used in practice. Also, unlike Sorkine et al., I will restrict myself to two dimensions, as we are only editing a curve in the plane.

Let the $V$ denote the initial positions of the control points before movement, consisting of the individual nodes positions $\mathbf{v}_i \in V$. Next, let $U \subset \mathbb{Z}$ be a set of indices refering to points we want to keep fixed, and let $\mathbf{u}_i$ be the fixed positions of $\mathbf{v}_i \in V$ for each $ i \in U$. Given the fixed positions $\mathbf{u}_i$ and the initial positions $V$, we want to compute the new positions $V'$, consisting of the individual positions $\mathbf{v}'_i \in V'$, that preserve the local structure of the curve, while also conforming to the new fixed positions.

In practice, $V$ will be a column vector of length $2n$, $n$ being the number of points. The $n$ first elements will be the $x$-coordinates of the points $\mathbf{v}_{i_x}$, $i \in [1..n]$, and the final $n$ elements will be the $y$-coordinates. $V'$ will have a similar structure.

The basic procedure for editing the curve will consist of the user choosing a set of points (the region of interest, RoI), that can be manipulated, and then dragging one of these (the ``handle'') to a new position. In this case, the set of indices for fixed points $U$ will contain the index of all points not in the RoI, in addition to the point dragged by the user. As a result, the algorithm will compute a new curve by mostly moving the points in the RoI to be consistent with the points outside the RoI and the new position of the handle.

Let $\mathcal{\mathbf{v_i}}$ denote the Laplacian of vector $\mathbf{v_i}$. If we let $\mathcal{N}_i$ denote the set of neighbors to vertex $i$, whichin case of a curve  will be $i+1$ and $i - 1$, provided they exist. The Laplacian of a vertex can now be written as $\mathcal{L}(\mathbf{v_i}) = \mathbf{v_i} - \sum_{j \in \mathcal{N}_i}\mathbf{v_j} / |\mathcal{N}_i|$. We see that this transform is linear in the positions of the curve, so that we can let $L$ be the \textit{Laplacian matrix} such that $L\cdot V$ produces the vector $\Delta$ containing the Laplacian coordinates of the vertices. Denote the Laplacian transformation of $\mathbf{v}_i$ as $\mathbf{\delta}_i$.

We will formulate the problem as a sparse linear system, which may subsequently be solved with an off-the-shelf solver. Consider the following energy function:

\[
E_0(V') = \sum_{i = 1}^n || \mathbf{\delta}_i - \mathcal{L}(\mathbf{v'}_i) ||^2 + \sum_{i \in U} || \mathbf{v}_i - \mathbf{v'}_i||^2
\]

When minimizing this function, the first term will ensure that the laplacian of the new and old points stay mostly the same, and the second term will ensure that our fixed points stay close to their original positions.

One aspect that this formulation does not account for, is that movement of a point will disallow rotation and scaling of the Laplacian coordinates, although in general, we want to allow for those transformations to occur. 

Thus, we formulate a new energy function that can account for transformations:

\begin{equation}
  E(V') = \sum_{i = 1}^n || T_i(V') \mathbf{\delta}_i - \mathbf{\delta'}_i||^2 + \sum_{i \in U} || \mathbf{v}_i - \mathbf{v'}_i||^2.
  \label{eq1}
\end{equation}

We want to choose a transformation that minimizes the first term, in other words minimizes

\[
G_i(T_i) = || T_i\mathbf{v}_i - \mathbf{v'}_i ||^2 + \sum_{j \in \mathcal{N}_i}||T_i \mathbf{v}_j - \mathbf{v'}_j||^2
\]

We will discuss how to optimize for $V'$ and $T_i$ simultaneously, but first, we must note that if we leave $T_i$ unconstrained, the minimizer of $G_i$ will be a membrane solution, a solution where all vertices between two fixed vertices will form a straight line, which will defeat our purpose of creating a new ``naturally'' curved spline.

The solution to this, as proposed by Sorkine et al., is to only allow for isotropic scaling and small rotations. They argue that anisotropic scaling may flatten a point in its normal direction, diminishing its Laplacian coordinate. Specifically, the transformation will take the following form (in two dimensions):

\[
T_i = \left[
  \begin{matrix}
    s_i & -h_i \\
    h_i & s_i
  \end{matrix}
  \right]
\]

As we see, only small rotations (with $h_i = \sin \theta$, $\theta$ being the angle of rotation) will be describable with reasonable accuracy by this matrix, although Sorkine et al. propose ways of working around this restriction.

An important question remains - how can we formulate an optimization problem where both $V'$ and the $T_i$'s are unknown? The solution provided by Sorkine et al. is to formulate $T_i$ as a linear function of $V'$, and encorporate the coefficients of that linear function into the original linear system. Practically, this is done in the following way:

First, we formulate an optimization problem to find the coefficients $[s_i, h_i]^T$ from $G_i$. We see that if we let

\[
A_i = \begin{bmatrix}
  v_{k_x} & -v_{k_y} \\
  \vdots &  \vdots \\
  v_{k_y} &  v_{k_x} \\
  \vdots &  \vdots
\end{bmatrix}
\text{ for } k \in \{i\} + \mathcal{N}_i
\],

the energy function $G_i$ can simply be written as

\[
||A_i[s_i, h_i]^T - \mathbf{b}_i||^2
\]

where $\mathbf{b}_i$ is defined by

\[
\mathbf{b}_i = \begin{bmatrix}
  v'_{k_x} \\
  \vdots \\
  v'_{k_y} \\
  \vdots
\end{bmatrix}
\text{ for } k \in \{i\} + \mathcal{N}_i
\],

This is a least-squares problem with the closed-form solution

\[
\begin{bmatrix}
  s_i \\
  h_i \\
\end{bmatrix}
= (A_i^TA_i)^{-1}A_i^T\mathbf{b}_i
\].

We thus see that the coefficients of $T_i$ are linear in $V'$. Let $M_i = (A_i^TA_i)^{-1}A_i^T\mathbf{b}_i$. We now turn our attention back to the energy function $E(V')$. We will minimize it by formulating it as quadratic optimization problem $||BV' - \mathbf{c}||^2$, where $B$ has dimensions $(2n + 2|U|) \times 2n$ and $\mathbf{c}$ has dimensions $(2n + 2|U|) \times 1$.

We first discuss the structure of $\mathbf{c}$. The first $2n$ elements will all be zero, as we simply wish to minimize the dot products of $V'$ with the first $2n$ rows of $B$, which we will discuss in a bit. The final $2|U|$ rows of $\mathbf{c}$ contain first the $x$-coordinates of all the fixed points, and then the $y$-coordinates, or algebraically:

\[
\mathbf{c} = 
\begin{bmatrix}
  0 \\
  \vdots \\
  0 \\
  v_{u_x} \\
  \vdots \\
  v_{u_y} \\
  \vdots
\end{bmatrix}
\text{ for } u \in U
\]

Next, we define the rows of $B$. The $2n$ first rows will describe the terms $T_i(V')\mathbf{\delta}_i - \mathbf{\delta'}_i$ of equation \ref{eq1}, separated into $x$- and $y$-components as usual. The $x$-part of the term translates into $s_i\mathbf{\delta}_{i_x} + h_i\mathbf{\delta}_{i_y} - \mathbf{\delta'}_{i_x}$. But, as we have seen, $s_i$ and $h_i$ can be written as linear functions of $V'$ using the aforementioned matrix $M_i$. Let $M'_{i_1}$ be a row vector of $2n$ elements containing the components of row 1 of $M_i$, such that each component has the same position in $M'_{i_1}$ as the corresponding component in $\mathbf{b}_i$ has in $V'$. In other words, so that $M'_{i_1}V' = s_i$. Similarily, let $M'_{i_2}$ be the vector so that $M'_{i_2}V' = h_i$.

Having these definitions handy, we now see that $s_i\mathbf{\delta}_{i_x} + h_i\mathbf{\delta}_{i_y} - \mathbf{\delta'}_{i_x} = (\mathbf{\delta}_{i_x}M'_{i_1} + \mathbf{\delta}_{i_y}M'_{i_2} - L_i)V'$, where $L_i$ is the $i$'th row of the Laplacian, so that the left-hand factor of the last expression will be the $i$'th row of $B$ for $i \leq n$. For $i > n$, we have a corresponding expression, but for the $y$-component of the term $T_i(V') \mathbf{\delta}_i - \mathbf{\delta'}_i$.

The final $2|U|$ rows of $B$ will have a single 1 each, on the position corresponding to component of $\mathbf{v'}_u$ for $u \in U$ in the same row of $\mathbf{c}$. In notation, row $i$ of $B$ will look like this:

\[
B_i = \left\{\begin{array}{lr}
\mathbf{\delta}_{i_x}M'_{i_1} - \mathbf{\delta}_{i_y}M'_{i_2} - L_i & \text{for } i \leq n \\
\mathbf{\delta}_{{(i-n)}_x}M'_{{(i-n)}_2} + \mathbf{\delta}_{{(i-n)}_y}M'_{{(i-n)}_1} - L_{i-n} & \text{for } n < i \leq 2n \\
\mathbf{e}^T_{u_{(i - 2n)}} & \text{for } 2n < i \leq 2n + |U| \\
\mathbf{e}^T_{n + u_{(i - 2n - |U|)}} & \text{for } 2n + |U| < i \leq 2n + 2|U|
\end{array}\right\}
\]

where $\mathbf{e_i}$ is the column vector with zeros everywhere except on position $i$, and $u_i$ is the $i$'th integer in $U$, in the same order as in the definition of $\mathbf{c}$.

Finally, we but the pieces together and conclude that the minimization objective

\[
||BV'- \mathbf{c}||^2
\]

is a sparse system with unknown vector $V'$. The system is overdetermined, so we find the least squares solution by solving the sparse linear system

\[
B^TBV' = B^T\mathbf{c}
\],
so that, in the end, we find the new curve vertices $V'$.

\subsubsection{Harder Restrictions on Fixed Points}

Although the Laplacian Curve Editing approach provides an intuitive approach to editing the curve, the fixed points were found to move an unacceptable amount due to having a least-squares constraint and not being completely fixed. ParaGem probably encounters this problem because the ratio of the number movable points to the number of fixed points is generally higher than in the work by Sorkine et al., so that the quadratic objective function receive less influence from the fixed points altogether.

This is fixed by imposing a larger weight on the fixed-point terms of the optimization objective, implemented by multiplying both the non-zero elements of the $2|U|$ bottom rows of $B$ and the last $2|U|$ elements of $\mathbf{c}$ by the same constant factor.

\subsubsection{Peeling}

In addition to traditional Laplacian curve editing, I have also implemented \textit{peeling}, as presented in \cite{rigid_igarashi} and used in \cite{gingold09}. Peeling is closely related to Laplacian curve editing, but while the latter requires a pre-specified region of movable points (the Region of Interest), this region is dynamic in peeling. More specifically, the user starts by choosing a single point of the curve, and drags it in the desired direction. The region of interest grows along the curve in both directions as the user drags the point. The further away from the original position the point is dragged, the greater the region of interest becomes.

Both peeling and traditional Laplacian curve editing are implemented and available for the user.

\pagebreak

\section{Implementation Details} \label{section_implementation}

% Is there much to say here? Used Rust? Used OpenGL, ImGUI, nalgebra..

\pagebreak

\section{Future Work} \label{section_future_work}

% I go through both what is needed to finish this project, and 

\subsection{Planned Application Features}

% Submodels
% Row-/grid-arrangement of submodels
% Parameters-per-submodel
% Functions over parameters for row-grid-arrangements of submodels

% More primitives (cuboids, tetrahedra, ellipsoids, sheets (?))

% Inter-annotation restrictions

% 3D edit

\subsection{Future Directions}

% Discuss issues regarding usability (starting to be rather complex)

% Mention textures (noise-driven?), both as fine-grained detail and color textures.

% Include \cite{schmidt08} - work that is a bit more related to what I have in mind (but perhaps not as ambitious, with recursion and stuff).
% This could also be used to create terrains (submodels are not just additive, but can be subtractive or just surface modifications instead)



\section{Conclusions} \label{section_conclusion}

% Project not finished, but we have shown examples of it working (make sure to actually show examples of it working)

\bibliography{report}
\bibliographystyle{plain}

\end{document}
